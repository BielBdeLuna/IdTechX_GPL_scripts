// this file is GPLv3

boolean ai_bipped::check_sight() {
    entity enemy, ent;

    enemy = NULL;

    //sight
    ent = findEnemy( current_fov ); //find the player?
    if ( ent && self.distanceTo( ent ) <= blind )  {
            enemy = ent;
    }

    if ( !enemy ) {
        ent = findEnemyAI( current_fov ); // find an enemy NPC?
        if ( ent && self.distanceTo( ent ) <= blind )  {
                enemy = ent;
        }
    }    

    if ( enemy ) {
        self.setEnemy( enemy );
        goal = enemy;
        return true;
    }

    return false;
}

boolean ai_bipped::check_hearing() {
    entity ent;

    ent = heardSound( true );
    if ( ent && self. distanceTo( ent ) <= deaf ) {
        enquiry_pos = ent.getWorldPosition();
        return true;
    }
    return false;
}

void ai_bipped::check_senses() {
    entity ent, enemy, old_enemy;

    if ( ( old_goal.getKey( "spawnclass" ) == ( "idAI" || "idPlayer" ) ) && old_goal.getHealth() > 0 ) {
        old_enemy = old_goal;
    } else {
        old_enemy = NULL;
    }

    //get an entity to play with
    //  sight
    ent = findEnemy( current_fov ); // let's find a player
    if ( ent ) {
        if ( self. distanceTo( ent ) <= blind ) { // it can't be zero because it would mean the enmy is within the monster, which is impossible
            enemy = ent;
        } else {
            enemy = NULL;
        }
    } else {
        ent = findEnemyAI( current_fov ); // let's find an enemy AI
        if ( ent && self. distanceTo( ent ) <= blind ) {
            enemy = ent;
        } else {
            enemy = NULL;
        }
    }
    
    // sound - let's only check sound if we haven't yet sighted the enemy
    if ( !enemy ) {
        ent = heardSound( true ); // TODO add find the source of the sound as a goal
        if ( ent && self. distanceTo( ent ) <= deaf ) {
            enemy = ent;
        } else {
            enemy = NULL;
        }
    }

    if ( enemy ) {
        goal = enemy;
        set_enemy( goal );
        old_goal = NULL;
        return true;
    } else {
        enemy = NULL;
    }

    if ( old_enemy ) {
        if ( old_enemy.getHealth() > 0 ) ) {
            goal = old_goal;
            set_enemy( goal );
            old_goal = NULL;
            return true;
        } else {
            goal = NULL;
        }
    } 
    return false;
}
/*
    updates the direction of the combat from the 'character' point of view, 
    that is the direction he has to take to combat the enemy, 
    this isn't dependant on the direction of any participant.
*/
void update_combat_dir() {
    combat_dir = vec_delta_dir ( self.getWorldOrigin(), goal.getWorldOrigin() );
}

void update_combat_node() {
    entity ent;

    ent = getCombatNode();

    if ( combat_node ) {
        

        if ( IN_NODE ) {
            if ( ( ent != combat_node ) && ( STRATEGY_MOVE ) ) {
                combat_node = ent;
            }            
        }

        if ( !canReachEntity( combat_node ) ) {
            combat_node.markUsed(); //it might not be used but since we can't reach it we better forget about it
            combat_node = ent;
        }
    } else {
        combat_node = ent; // it should get the closest node
    }
}

void test_exposed_now() {
    update_combat_dir();

    if ( check_dir_inverse_alignment ( combat_dir, sys.angToForward( goal.getAngles() ), 45 ) {
        if ( vec_delta_dist ( self.getWorldOrigin(), goal.getWorldOrigin() ) < AI_RANGE_MEDIUM  ) {
            if ( canHitEnemy() ) {
                //so he can hit back
                EXPOSED_TO_FIRE = true; // we are exposed
            }
        }
    }
    EXPOSED_TO_FIRE = false;
}

boolean check_exposed( boolean test_range, float enemy_alignment_angle_threshold ) {
    update_combat_dir();

    if ( check_dir_inverse_alignment ( combat_dir, sys.angToForward( goal.getAngles() ), enemy_alignment_angle_threshold ) {
        if ( canHitEnemy() ) {
            //so he can hit back
            if ( test_range ) {
                if ( vec_delta_dist ( self.getWorldOrigin(), goal.getWorldOrigin() ) < AI_RANGE_MEDIUM  ) {
                    return true;
                }
            } else {
                return true;
            }
        }
    }
    return = false;
}


boolean check_enemy_pinned() {

    if ( !canHitEnemy() ) {
        if ( sys.vecLenght( goal.getLinearVelocity() ) == 0 ) {
            return true; // he is waiting the shooting to stop
        }
    }
    return false;
}

boolean check_if_cover_is_optimal( entity cover ) {
    vector coverDir = sys.angtoForward( cover.getAngles() )

    update_combat_dir();

    if (  check_alignment( coverDir, combat_dir, 45 )  ) {
        return true;
    }
    return false;
}

void update_weapon_strategy() {
        float result = 0; // shoot or not shoot?

        if ( w_current_clip != w_full_clip ) {
            result --1;
            if ( w_current_clip <= ( w_full_clip / 2 ) {
                result --1;
                if ( w_current_clip <= ( w_full_clip / 4 ) {
                    result --1;
                    
                }    
            }
        } else {
            result ++1;
        }

        //can we reload in a node?
        if ( IN_NODE ) {
            result --1; // we actually favour reloading when in cover
        } else {
            result ++1;
        }

        //can we shoot the enemy?

        if ( canHitEnemy() ) {
            result ++1;
        } else {
            result --1;
        }

        //is the enemy facing us? ar we exposed to his posible fire?
        
        if ( check_exposed( false, 45 ) ) {
            result ++1;
        } else {
            result --1;
        }

        if ( result > 0 ) {
            //we end up favouring shooting
            if ( w_current_clip != w_full_clip ) {
                weapon_strategy = W_LAST_BULLETS;
            } else {
                weapon_strategy = W_SPRAY_AND_PRAY;
            }
        } else if ( result < 0 ) {
            //we end up favouring reloading the weapon
            weapon_strategy = W_NEED_TO_RELOAD;            
        } else {
            //we end up inb naither state
            if ( w_current_clip != w_full_clip ) {
                weapon_strategy = W_NEED_TO_RELOAD;
            } else {
                weapon_strategy = W_SPRAY_AND_PRAY;
            }            
        }
}

void update_situational_strategy() {
    float result = 0; //move or stay
    if( IN_NODE ) {
        //TODO do soemthing
    }
}

void update_strategy() {
    float result;
    entity  cover;

    result = 0;

    //value every situation, and depending in the result we will take an strategy ot the other

    // is the enemy pinned?
        if ( check_enemy_pinned() ) {
            result ++1;
        }

    cover = getCombatNode();

    // do we need to gain terrain?
        if ( check_gain_position() ) {
            result ++1;
        }        

    // is my weapon loaded?
        if ( w_current_clip != w_full_clip ) {
            result ++1;
            if ( w_current_clip <= ( w_full_clip / 2 ) {
                result ++1;
                if ( w_current_clip <= ( w_full_clip / 4 ) {
                    result ++1;
                    
                }    
            }
        }

    //strive for cover

    // are we in cover?
        if ( IN_NODE ) {

        }

    // do we have an optimal cover?
        if ( cover && check_if_cover_is_optimal( cover ) ) {
            result ++1;
        } 

    // did we get pain
        if ( sys.getTime() < in_pain_time ) {
            // we've just recieved pain
            result ++100;            
        }
    // are we low on health?
        if ( health <= max_health / 2 ) {
            result ++1000;
            if ( health <= max_health / 4 ) {
                result ++1000;
            }
        }

     // are we exposed?
        if ( EXPOSED_TO_FIRE ) {
            result ++100;
        }

    

    if ( result ) {

    } else {

    }
}

float update_attack_flags() {
    // this is a lineal check so let's make so the monster is the most protected he can
    // first the melee attack, then the gun attack, then magic attack and eventually the special attack
    // if none of the above applies make it a lost chance

    // let's say that this function it's not the most creative ever

    attack_flags = 0;
    float enemy_range = check_ai_range( self, goal );

    if ( enemy_range <= AI_RANGE_INFRONT ) {
        if ( testMeleeAttack() ) {
            attack_flags |= ATTACK_MELEE;
        } else {
            attack_flags |= ATTACK_LOST_CHANCE;
        }
    } else if ( canHitEnemy() ) {
        if ( enemy_range > AI_RANGE_INFRONT ) {
            attack_flags |= ATTACK_RANGED ;
        } 
    } else if ( canSee( goal ) == false ) {
            attack_flags |= ATTACK_MAGIC ;
    } else { 
        attack_flags |= ATTACK_LOST_CHANCE; 
    }

    return attack_flags
}




