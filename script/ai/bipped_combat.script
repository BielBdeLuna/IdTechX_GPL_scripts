// this file is GPLv3

boolean ai_bipped::check_sight() {
    entity enemy, ent;

    enemy = NULL;

    //sight
    ent = findEnemy( current_fov ); //find the player?
    if ( ent && self.distanceTo( ent ) <= blind )  {
            enemy = ent;
    }

    if ( !enemy ) {
        ent = findEnemyAI( current_fov ); // find an enemy NPC?
        if ( ent && self.distanceTo( ent ) <= blind )  {
                enemy = ent;
        }
    }    

    if ( enemy ) {
        self.setEnemy( enemy );
        goal = enemy;
        return true;
    }

    return false;
}

boolean ai_bipped::check_hearing() {
    entity ent;

    ent = heardSound( true );
    if ( ent && self. distanceTo( ent ) <= deaf ) {
        enquiry_pos = ent.getWorldPosition();
        return true;
    }
    return false;
}

boolean ai_bipped::check_senses() {
    entity ent, old_enemy;
    boolean old_enemy, got_enemy;

    //get an entity to play with
    //  sight
    ent = findEnemy( current_fov ); // let's find a player
    if ( ent ) {
        if ( self. distanceTo( ent ) <= blind ) { // it can't be zero because it would mean the enmy is within the monster, which is impossible
            got_enemy = true;
        } else {
            got_enemy = false;
        }
    } else {
        ent = findEnemyAI( current_fov ); // let's find an enemy AI
        if ( ent && self. distanceTo( ent ) <= blind ) {
            got_enemy = true;
        } else {
            got_enemy = false;
        }
    }
        
    // sound - let's only check sound if we haven't yet sighted the enemy
    if ( !got_enemy ) {
        ent = heardSound( true ); // TODO add find the source of the sound as a goal
        if ( ent && self. distanceTo( ent ) <= deaf ) {
            got_enemy = true;
        } else {
            got_enemy = false;
        }
    }

    if ( got_enemy ) {
        goal = ent;
        set_enemy( goal );
        return true;
    } else {
        old_enemy = false;
        if ( ( old_goal.getKey( "spawnclass" ) == ( "idAI" || "idPlayer" ) ) && old_goal.getHealth() > 0 ) {
            old_enemy = true;
        }

        if ( old_enemy ) {
            goal = old_goal;
            set_enemy( goal );
            return true;
        }
    }

    return false;
}
/*
    updates the direction of the combat from the 'character' point of view, 
    that is the direction he has to take to combat the enemy, 
    this isn't dependant on the direction of any participant.
*/
void update_combat_dir() {
    combat_dir = vec_delta_dir ( self.getWorldOrigin(), goal.getWorldOrigin() );
}

void update_combat_node() {
    entity ent;

    ent = getCombatNode();

    if ( combat_node ) {
        

        if ( IN_NODE ) {
            if ( ( ent != combat_node ) && ( STRATEGY_MOVE ) ) {
                combat_node = ent;
            }            
        }

        if ( !canReachEntity( combat_node ) ) {
            combat_node.markUsed(); //it might not be used but since we can't reach it we better forget about it
            combat_node = ent;
        }
    } else {
        combat_node = ent; // it should get the closest node
    }
}

void test_exposed_now() {
    update_combat_dir();

    if ( check_dir_inverse_alignment ( combat_dir, sys.angToForward( goal.getAngles() ), 45 ) {
        if ( vec_delta_dist ( self.getWorldOrigin(), goal.getWorldOrigin() ) < AI_RANGE_MEDIUM  ) {
            if ( canHitEnemy() ) {
                //so he can hit back
                EXPOSED_TO_FIRE = true; // we are exposed
            }
        }
    }
    EXPOSED_TO_FIRE = false;
}

boolean check_exposed( boolean test_range, float enemy_alignment_angle_threshold ) {
    update_combat_dir();

    if ( check_dir_inverse_alignment ( combat_dir, sys.angToForward( goal.getAngles() ), enemy_alignment_angle_threshold ) {
        if ( canHitEnemy() ) {
            //so he can hit back
            if ( test_range ) {
                if ( vec_delta_dist ( self.getWorldOrigin(), goal.getWorldOrigin() ) < AI_RANGE_MEDIUM  ) {
                    return true;
                }
            } else {
                return true;
            }
        }
    }
    return = false;
}


boolean check_enemy_pinned() {

    if ( !canHitEnemy() ) {
        if ( sys.vecLenght( goal.getLinearVelocity() ) == 0 ) {
            return true; // he is waiting the shooting to stop
        }
    }
    return false;
}

boolean check_if_cover_is_optimal( entity cover ) {
    vector coverDir = sys.angtoForward( cover.getAngles() )

    update_combat_dir();

    if (  check_alignment( coverDir, combat_dir, 45 )  ) {
        return true;
    }
    return false;
}

void update_weapon_strategy() {
        float result = 0; // shoot or not shoot?

        if ( w_current_clip != w_full_clip ) {
            result --1;
            if ( w_current_clip <= ( w_full_clip / 2 ) {
                result --1;
                if ( w_current_clip <= ( w_full_clip / 4 ) {
                    result --1;
                    
                }    
            }
        } else {
            result ++1;
        }

        //can we reload in a node?
        if ( IN_NODE ) {
            result --1; // we actually favour reloading when in cover
        } else {
            result ++1;
        }

        //can we shoot the enemy?

        if ( canHitEnemy() ) {
            result ++1;
        } else {
            result --1;
        }

        //is the enemy facing us? ar we exposed to his posible fire?
        
        if ( check_exposed( false, 45 ) ) {
            result ++1;
        } else {
            result --1;
        }

        if ( result > 0 ) {
            //we end up favouring shooting
            if ( w_current_clip != w_full_clip ) {
                weapon_strategy = W_LAST_BULLETS;
            } else {
                weapon_strategy = W_SPRAY_AND_PRAY;
            }
        } else if ( result < 0 ) {
            //we end up favouring reloading the weapon
            weapon_strategy = W_NEED_TO_RELOAD;            
        } else {
            //we end up inb naither state
            if ( w_current_clip != w_full_clip ) {
                weapon_strategy = W_NEED_TO_RELOAD;
            } else {
                weapon_strategy = W_SPRAY_AND_PRAY;
            }            
        }
}

void update_situational_strategy() {
    float result = 0; //move or stay
    if( IN_NODE ) {
        //TODO do soemthing
    }
}

void update_strategy() {
    float result;
    entity  cover;

    result = 0;

    //value every situation, and depending in the result we will take an strategy ot the other

    // is the enemy pinned?
        if ( check_enemy_pinned() ) {
            result ++1;
        }

    cover = getCombatNode();

    // do we need to gain terrain?
        if ( check_gain_position() ) {
            result ++1;
        }        

    // is my weapon loaded?
        if ( w_current_clip != w_full_clip ) {
            result ++1;
            if ( w_current_clip <= ( w_full_clip / 2 ) {
                result ++1;
                if ( w_current_clip <= ( w_full_clip / 4 ) {
                    result ++1;
                    
                }    
            }
        }

    //strive for cover

    // are we in cover?
        if ( IN_NODE ) {

        }

    // do we have an optimal cover?
        if ( cover && check_if_cover_is_optimal( cover ) ) {
            result ++1;
        } 

    // did we get pain
        if ( sys.getTime() < in_pain_time ) {
            // we've just recieved pain
            result ++100;            
        }
    // are we low on health?
        if ( health <= max_health / 2 ) {
            result ++1000;
            if ( health <= max_health / 4 ) {
                result ++1000;
            }
        }

     // are we exposed?
        if ( EXPOSED_TO_FIRE ) {
            result ++100;
        }

    

    if ( result ) {

    } else {

    }
}
/*
float update_attack_flags() {
    // this is a lineal check so let's make so the monster is the most protected he can
    // first the melee attack, then the gun attack, then magic attack and eventually the special attack
    // if none of the above applies make it a lost chance

    // let's say that this function it's not the most creative ever

    attack_flags = 0;
    float enemy_range = check_ai_range( self, goal );

    if ( enemy_range <= AI_RANGE_INFRONT ) {
        if ( testMeleeAttack() ) {
            attack_flags |= ATTACK_MELEE;
        } else {
            attack_flags |= ATTACK_LOST_CHANCE;
        }
    } else if ( canHitEnemy() ) {
        if ( enemy_range > AI_RANGE_INFRONT ) {
            attack_flags |= ATTACK_RANGED;
        } 
    } else if ( canSee( goal ) == false ) {
            attack_flags |= ATTACK_MAGIC;
    } else { 
        attack_flags |= ATTACK_LOST_CHANCE; 
    }

    return attack_flags;
}
*/
boolean try_to_find_the_enemy() {
    if ( check_if_in_enemy_last_pos && ( sys.getTime() > ( time_searching_goal + time_max_searching_goal ) ) ) {
        // time has passed
        return false;           
    }

    if ( check_senses() ) {
        enemy_lost = false
    }

    return true;
}

boolean check_enemy_lost() {
    boolean seeIt, hearIt;

    if ( !goal ) {
        // the enemy is dead
        return enemy_lost;
    }

    // do we see him
    seeIt = canSee( goal );
    if ( !seeIt ) {
        //do we hear him?
        hearIt = ( self.heardSound( false ) == goal );
    }

    // if seen or heard it it's not lost
    enemy_lost = !( seeIt | hearIt ); 

    return enemy_lost;
}

float decide_attack_action() {
    float attack, enemy_range;

    if ( ( check_enemy_lost() ) || ( in_pain_time > sys.getTime() ) ) {
        attack = ATTACK_NONE;
    } else {
        enemy_range = check_ai_range( self, goal );        
        
        if ( ( enemy_range <= AI_RANGE_INFRONT ) && testMeleeAttack() ) {
            attack = ATTACK_MELEE;
        } else if ( canHitEnemy() && ( enemy_range > AI_RANGE_INFRONT ) ) {
            attack = ATTACK_RANGED;
        } else if ( !canSee( goal ) ) {
            attack = ATTACK_MAGIC;
        } else {
            attack = ATTACK_LOST_CHANCE;
        }
    }
    
    return attack;
}

void perform_attack_action( float a ) {
    float t = sys.getTime();

    time_next_attack = t + TIME_NEXT_ATTACK;

    if ( a == ATTACK_LOST_CHANCE ) {
        evasive_manuever( true );
    } else {
        enemy_last_position = enemy.getWorldORigin();
        enemy_last_angles = enemy.getAngles();
        time_searching_goal = sys.getTime(); // 4 seconds after it'll be considered lost, so we still can attack him with magic (when not seeing him)
    
        if ( a = ATTACK_NONE ) {
            evasive_manuever( false );
        } else if ( a == ATTACK_MELEE ) {
            // random chose a melee aniamtion
        } else if ( a == ATTACK_RANGED ) {
            //shoot aniamtion
        } else {
            //do the magic attack whether h teleports around the player or attacks him somewhat magically
        }
    }
}

void evasive_manuever( boolean voaclize ) {
    if ( vocalize ) {
        //say something
    }
    //choose a direction
    //run a cycle there
}

void serch_enemy() {

    


    TurnTo( enemy_last_angles.y ); // the enemy last yaw
}

void serch_enemy_last_position() {
    /*
    we can see the position form there
        the enemy is there
            attack him
        else
            chwenge state_to_search_enemy
}



