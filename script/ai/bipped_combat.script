// this file is GPLv3

boolean ai_bipped::check_sight() {
    entity enemy, ent;

    enemy = NULL;

    //sight
    ent = findEnemy( current_fov ); //find the player?
    if ( ent && self.distanceTo( ent ) <= blind )  {
            enemy = ent;
    }

    if ( !enemy ) {
        ent = findEnemyAI( current_fov ); // find an enemy NPC?
        if ( ent && self.distanceTo( ent ) <= blind )  {
                enemy = ent;
        }
    }    

    if ( enemy ) {
        self.setEnemy( enemy );
        goal = enemy;
        return true;
    }

    return false;
}

boolean ai_bipped::check_hearing() {
    entity ent;

    ent = heardSound( true );
    if ( ent && self. distanceTo( ent ) <= deaf ) {
        enquiry_pos = ent.getWorldPosition();
        return true;
    }
    return false;
}

void ai_bipped::check_senses() {
    entity ent, enemy, old_enemy;

    if ( ( old_goal.getKey( "spawnclass" ) == ( "idAI" || "idPlayer" ) ) && old_goal.getHealth() > 0 ) {
        old_enemy = old_goal;
    } else {
        old_enemy = NULL;
    }

    //get an entity to play with
    //  sight
    ent = findEnemy( current_fov ); // let's find a player
    if ( ent ) {
        if ( self. distanceTo( ent ) <= blind ) { // it can't be zero because it would mean the enmy is within the monster, which is impossible
            enemy = ent;
        } else {
            enemy = NULL;
        }
    } else {
        ent = findEnemyAI( current_fov ); // let's find an enemy AI
        if ( ent && self. distanceTo( ent ) <= blind ) {
            enemy = ent;
        } else {
            enemy = NULL;
        }
    }
    
    // sound - let's only check sound if we haven't yet sighted the enemy
    if ( !enemy ) {
        ent = heardSound( true ); // TODO add find the source of the sound as a goal
        if ( ent && self. distanceTo( ent ) <= deaf ) {
            enemy = ent;
        } else {
            enemy = NULL;
        }
    }

    if ( enemy ) {
        goal = enemy;
        set_enemy( goal );
        old_goal = NULL;
        return true;
    } else {
        enemy = NULL;
    }

    if ( old_enemy ) {
        if ( old_enemy.getHealth() > 0 ) ) {
            goal = old_goal;
            set_enemy( goal );
            old_goal = NULL;
            return true;
        } else {
            goal = NULL;
        }
    } 
    return false;
}
/*
    updates the direction of the combat from the 'character' point of view, 
    that is the direction he has to take to combat the enemy, 
    this isn't dependant on the direction of any participant.
*/
void update_combat_dir() {
    combat_dir = vec_delta_dir ( self.getWorldOrigin(), goal.getWorldOrigin() );
}

void update_combat_node() {
    entity ent;

    ent = getCombatNode();

    if ( combat_node ) {
        

        if ( IN_NODE ) {
            if ( ( ent != combat_node ) && ( STRATEGY_MOVE ) ) {
                combat_node = ent;
            }            
        }

        if ( !canReachEntity( combat_node ) ) {
            combat_node.markUsed(); //it might not be used but since we can't reach it we better forget about it
            combat_node = ent;
        }
    } else {
        combat_node = ent; // it should get the closest node
    }
}

void test_exposed_now() {
    update_combat_dir();

    if ( check_dir_inverse_alignment ( combat_dir, sys.angToForward( goal.getAngles() ), 45 ) {
        if ( vec_delta_dist ( self.getWorldOrigin(), goal.getWorldOrigin() ) < AI_RANGE_MEDIUM  ) {
            if ( canHitEnemy() ) {
                //so he can hit back
                EXPOSED_TO_FIRE = true; // we are exposed
            }
        }
    }
    EXPOSED_TO_FIRE = false;
}


boolean check_enemy_pinned() {

    if ( !canHitEnemy() ) {
        if ( sys.vecLenght( goal.getLinearVelocity() ) == 0 ) {
            return true; // he is waiting the shooting to stop
        }
    }
    return false;
}

boolean check_if_cover_is_optimal( entity cover ) {
    vector coverDir = sys.angtoForward( cover.getAngles() )

    update_combat_dir();

    if (  check_alignment( coverDir, combat_dir, 45 )  ) {
        return true;
    }
    return false;
}

void update_strategy() {
    float result;
    entity  cover;

    result = 0;

    //value every situation, and depending in the result we will take an strategy ot the other

    // is the enemy pinned?
        if ( check_enemy_pinned() ) {
            result ++1;
        }

    // are we in cover?
        if ( IN_NODE ) {

        }

    cover = getCombatNode();

    // do we have an optimal cover?
        if ( cover && check_if_cover_is_optimal( cover ) ) {
            result ++1;
        } 

    // do we need to gain terrain?
        if ( check_gain_position() ) {
            result ++1;
        }
        

    // is my weapon loaded?
        if ( w_currentClip != w_fullClip ) {
            result ++1;
        }

    // are we exposed?
        if ( EXPOSED_TO_FIRE ) {
            result = result + 100;
        }

    // did we get pain
        if ( sys.getTime() < nextPainTime ) {
            // we've just recieved pain
            result = result + 100;            
        }

    

    if ( result ) {

    } else {

    }
}




